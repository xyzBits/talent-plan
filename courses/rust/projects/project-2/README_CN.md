# PNA Rust 项目 2：日志结构文件 I/O

**任务**：创建一个**持久化**的键/值存储，并支持**通过命令行访问**。

**目标**：

- 健壮地处理并报告错误
- 使用 serde 进行序列化
- 使用标准文件 API 将数据作为日志写入磁盘
- 从磁盘读取键/值存储的状态
- 将内存中的键索引映射到磁盘上的值
- 定期压缩日志以移除过时数据

**主题**：日志结构文件 I/O、bitcask、`failure` 库、`Read` / `Write` 特性、`serde` 库。

- [简介](#简介)
- [术语](#术语)
- [项目规范](#项目规范)
- [项目设置](#项目设置)
- [第 1 部分：错误处理](#第-1-部分错误处理)
- [第 2 部分：日志的行为方式](#第-2-部分日志的行为方式)
- [第 3 部分：写入日志](#第-3-部分写入日志)
- [第 4 部分：从日志读取](#第-4-部分从日志读取)
- [第 5 部分：在索引中存储日志指针](#第-5-部分在索引中存储日志指针)
- [第 6 部分：无状态 vs 有状态 `KvStore`](#第-6-部分无状态-vs-有状态-kvstore)
- [第 7 部分：日志压缩](#第-7-部分日志压缩)

## 简介

在这个项目中，你将创建一个简单的磁盘键/值存储，可以通过命令行进行修改和查询。它将使用 [bitcask] 所使用的存储算法的简化版本，选择该算法是因为它结合了简单性和有效性。首先，你将在磁盘上维护一个之前写入命令的**日志**（有时称为[“预写日志”][wal]或“WAL”），在启动时对其进行评估，以在内存中重新创建数据库的状态。然后，你将对其进行扩展，仅在内存中存储键，以及在磁盘日志中的偏移量。最后，你将引入日志压缩，使其不会无限增长。在项目结束时，你将使用 Rust 文件 API 构建一个简单但架构良好的数据库。

[wal]: https://en.wikipedia.org/wiki/Write-ahead_logging
[bitcask]: https://github.com/basho/bitcask

## 术语

本课程中我们将使用的一些术语。它们与 [bitcask] 相同或受其启发。不同的数据库可能会有略微不同的术语。

- **命令 (command)** - 向数据库发出的请求或请求的表示。这些是在命令行或通过网络发出的。它们具有内存表示、文本表示和机器可读的序列化表示。
- **日志 (log)** - 磁盘上的命令序列，按最初接收和执行的顺序排列。我们数据库的磁盘格式几乎完全由日志组成。它将非常简单，但也非常高效。
- **日志指针 (log pointer)** - 日志中的文件偏移量。有时我们也直接称之为“文件偏移量”。
- **日志压缩 (log compaction)** - 随着写入操作的进行，有时会使旧的日志条目失效。例如，先写入键/值 `a = 0`，然后写入 `a = 1`，会使第一个关于 "a" 的日志条目失效。压缩 &mdash; 至少在我们的数据库中 &mdash; 是通过从日志中移除过时命令来减小数据库大小的过程。
- **内存索引 (in-memory index)**（或简称**索引**）- 键到日志指针的映射。当发出读取请求时，在内存索引中搜索适当的日志指针，找到后，从磁盘日志中检索该值。在我们的键/值存储中，就像在 bitcask 中一样，**整个数据库**的索引都存储在内存中。
- **索引文件 (index file)** - 内存索引在磁盘上的表示。如果没有这个文件，每次启动数据库时都需要完全重播日志以恢复内存索引的状态。

## 项目规范

cargo 项目 `kvs` 构建了一个名为 `kvs` 的命令行键值存储客户端，该客户端反过来调用一个名为 `kvs` 的库。

`kvs` 可执行文件支持以下命令行参数：

- `kvs set <KEY> <VALUE>`
  将字符串键的值设为字符串。
  失败时打印错误并返回非零退出代码。

- `kvs get <KEY>`
  获取给定字符串键的字符串值。
  失败时打印错误并返回非零退出代码。

- `kvs rm <KEY>`
  移除给定键。
  失败时打印错误并返回非零退出代码。

- `kvs -V`
  打印版本

`kvs` 库包含一个类型 `KvStore`，支持以下方法：

- `KvStore::set(&mut self, key: String, value: String) -> Result<()>`
  将字符串键的值设为字符串。
  如果值未成功写入，则返回错误。

- `KvStore::get(&mut self, key: String) -> Result<Option<String>>`
  获取字符串键的字符串值。
  如果键不存在，返回 `None`。
  如果值未成功读取，则返回错误。

- `KvStore::remove(&mut self, key: String) -> Result<()>`
  移除给定键。
  如果键不存在或未成功移除，则返回错误。

- `KvStore::open(path: impl Into<PathBuf>) -> Result<KvStore>`
  在给定路径打开 KvStore。
  返回 KvStore。

在将键设为值时，`kvs` 将 `set` 命令以顺序日志的形式写入磁盘，然后在内存索引中存储该命令的日志指针（文件偏移量）。在移除键时，类似地，`kvs` 在日志中写入 `rm` 命令，然后从内存索引中移除该键。当使用 `get` 命令检索键的值时，它搜索索引，如果找到，则从对应日志指针处加载日志中的命令，评估该命令并返回结果。

启动时，日志中的命令按从旧到新的顺序遍历，并重建内存索引。

当未压缩的日志条目大小达到给定阈值时，`kvs` 将其压缩到新日志中，移除冗余条目以回收磁盘空间。

请注意，我们的 `kvs` 项目既是一个无状态的命令行程序，也是一个包含有状态 `KvStore` 类型库：对于 CLI 使用，`KvStore` 类型将加载索引、执行命令，然后退出；对于库使用，它将加载索引，然后执行多个命令并维护索引状态，直到被释放。

## 项目设置

接续之前的项目，删除之前的 `tests` 目录，并将本项目的 `tests` 目录复制到相应位置。与之前的项目一样，本项目的库和可执行文件都应命名为 `kvs`。

你需要在 `Cargo.toml` 中添加以下开发依赖项：

```toml
[dev-dependencies]
assert_cmd = "0.11.0"
predicates = "1.0.0"
tempfile = "3.0.7"
walkdir = "2.2.7"
```

与之前的项目一样，先编写足够的空定义或带有 panic 的定义，使测试用例能够构建。

*现在就这样做。*

## 第 1 部分：错误处理

在这个项目中，代码可能会因为 I/O 错误而失败。因此，在开始实现数据库之前，我们需要做一件对 Rust 项目至关重要的事情：决定错误处理策略。

Rust 的错误处理功能强大，但正确使用起来涉及大量样板代码。在这个项目中，[`failure`] 库将提供轻松处理各类错误的工具。

[`failure`]: https://docs.rs/failure/0.1.5/failure/

[failure 指南][fg] 描述了[几种][several]错误处理模式。

[fg]: https://boats.gitlab.io/failure/
[several]: https://boats.gitlab.io/failure/guidance.html

选择其中一种策略，在你的库中要么定义自己的错误类型，要么导入 `failure` 的 `Error`。这是你在所有 `Result` 中使用的错误类型，使用 `?` 运算符将其他库的错误类型转换为你自己的。

之后，为 `Result` 定义一个包含你具体错误类型的类型别名，这样你就无需在到处输入 `Result<T, YourErrorType>`，而只需输入 `Result<T>`。这是一个常见的 Rust 模式。

最后，使用 `use` 语句将这些类型导入你的可执行文件，并将 `main` 的函数签名更改为返回 `Result<()>`。库中所有可能失败的函数都将把这些 `Result` 传递回调用栈，一直传到 `main`，然后传到 Rust 运行时，后者将打印错误。

运行 `cargo check` 查找编译器错误并修复。目前可以在 `main` 的结尾使用 `panic!()` 使项目能够构建。

*在继续之前，先设置好你的错误处理策略。*

与之前的项目一样，你需要创建占位数据结构和方法，以便测试通过编译。既然你已经定义了错误类型，这应该是直截了当的。在任何必要的地方添加 panic 以使测试套件能够编译（`cargo test --no-run`）。

## 第 2 部分：日志的行为方式

现在我们终于要开始通过磁盘读写来实现一个真实数据库的基础了。你将使用 [`serde`] 将 "set" 和 "rm" 命令序列化为字符串，并使用标准文件 I/O API 将其写入磁盘。

[`serde`]: https://serde.rs/

以下是 `kvs` 带有日志时的基本行为：

- **"set"**
  - 用户调用 `kvs set mykey myvalue`
  - `kvs` 创建一个表示 "set" 命令的值，包含其键和值
  - 然后将其序列化为 `String`
  - 接着将序列化后的命令追加到包含日志的文件中
  - 如果成功，静默退出，退出码为 0
  - 如果失败，打印错误并返回非零退出码退出
- **"get"**
  - 用户调用 `kvs get mykey`
  - `kvs` 读取整个日志，一次处理一个命令，将受影响的键和命令的文件偏移量记录到内存中的 *键 -> 日志指针* 映射中
  - 然后在映射中检查日志指针
  - 如果失败，打印 "Key not found" 并以退出码 0 退出
  - 如果成功
    - 反序列化命令以获取键的最后记录值
    - 将该值打印到 stdout 并以退出码 0 退出
- **"rm"**
  - 用户调用 `kvs rm mykey`
  - 与 "get" 命令相同，`kvs` 读取整个日志以构建内存索引
  - 然后检查映射中是否存在给定的键
  - 如果不存在，打印 "Key not found" 并以非零退出码退出
  - 如果成功
    - 创建一个表示 "rm" 命令的值，包含其键
    - 然后将序列化后的命令追加到日志中
    - 如果成功，静默退出，退出码为 0

日志是提交到数据库的任务记录。通过在启动时“重播”日志中的记录，我们可以重建数据库之前的状态。

在此迭代中，你可以直接在内存中存储键的值（从而在初始启动和日志重播后不再从日志中读取）。在未来的迭代中，你将仅在日志中存储“日志指针”（文件偏移量）。

## 第 3 部分：写入日志

首先通过实现 "set" 流程开始。这里有很多步骤。大多数步骤实现起来都很直截了当，你可以通过运行相应的 `cli_*` 测试用例来验证你的实现。

`serde` 是一个庞大的库，有很多选项，并支持许多序列化格式。基本的序列化和反序列化只需要正确地注释你的数据结构，并调用一个函数将其写入 `String` 或实现了 `Write` 的流中。

你需要选择一种序列化格式。考虑一下你希望序列化格式具备哪些属性 &mdash; 你是优先考虑性能？还是希望能够以纯文本形式读取日志内容？这是你的选择，但也许你应该在代码中添加注释说明原因。

其他需要考虑的事情包括：系统在哪里执行缓冲，以及你在哪里需要缓冲？缓冲对后续读取有什么影响？什么时候应该打开和关闭文件句柄？针对每个命令还是针对 `KvStore` 的生命周期？

你将调用的一些 API 可能会失败，并返回某种错误类型的 `Result`。请确保你的调用函数返回*你自己*错误类型的 `Result`，并使用 `?` 在两者之间进行转换。

这与实现 "rm" 命令类似，但在将命令写入日志之前，你还应该额外检查键是否存在。由于我们需要区分两种不同的命令，你可以使用单个枚举类型的变体来表示每个命令。`serde` 与枚举配合得非常完美。

你现在可以实现 "set" 和 "rm" 命令，重点关注 `set` / `rm` 测试用例，或者如果想了解 "get" 命令，可以继续阅读下一节。将两者都记在脑海中或者同时实现它们可能会有所帮助。这取决于你的选择。

## 第 4 部分：从日志读取

现在轮到实现 "get" 了。在这一部分，你不需要在索引中存储日志指针，我们将这项工作留给下一部分。相反，只需在启动时读取日志中的每个命令，执行它们以便将每个键和值保存在内存中。然后从内存中读取。

你应该将日志中的所有记录一次性读入内存，然后将它们重播到你的映射类型中；还是应该一边重播一边一次读取一个记录？在反序列化之前你应该先读入缓冲区，还是直接从文件流中反序列化？考虑一下你这种方案的内存使用情况。考虑一下从 I/O 流读取与内核交互的方式。

记住 "get" 可能找不到值，这种情况需要特殊处理。在这里，我们的 API 返回 `None`，而我们的命令行客户端打印一条特定的消息并以零退出码退出。

读取日志有一个复杂点，你可能在编写 "set" 代码时已经考虑过了：如何区分日志中的每条记录？也就是说，你怎么知道什么时候停止读取一条记录并开始读取下一条？你甚至需要这样做吗？也许 serde 会直接从 I/O 流中反序列化一条记录，并在完成后停止读取，使文件光标处于读取后续记录的正确位置。也许 serde 在看到两条背靠背的记录时会报告错误。也许你需要插入额外的信息来区分每条记录的长度。也许不需要。

*现在实现 "get"。*

## 第 5 部分：在索引中存储日志指针

到这一步，除了压缩测试外，大多数（如果不是全部）测试套件都应该已经通过了。接下来引入的更改是简单的优化，对于快速性能和减少存储空间是必要的。当你实现它们时，注意它们具体是在优化什么。

如前所述，你正在构建的数据库维护着数据库中所有键的内存索引。该索引从字符串键映射到日志指针，而不是值本身。

这一更改引入了在任意偏移量处从日志执行读取的需求。考虑一下这可能会如何影响你管理文件句柄的方式。

*如果在之前的步骤中你选择了直接在内存中存储字符串值，那么现在是将代码更新为存储日志指针并在需要时从磁盘加载的时候了。*

## 第 6 部分：无状态 vs 有状态 `KvStore`

记住我们的项目既是一个库也是一个命令行程序。它们的需求略有不同：`kvs` CLI 向磁盘提交一个更改，然后退出（它是无状态的）；`KvStore` 类型向磁盘提交更改，然后常驻内存以服务未来的查询（它是有状态的）。

你的 `KvStore` 是有状态的还是无状态的？

*让你的 `KvStore` 在内存中保留索引，这样它就不需要在每次调用 `get` 时重新评估索引。*

## 第 7 部分：日志压缩

到目前为止，数据库运行良好，但日志会无限增长。这对于某些数据库是合适的，但对于我们正在构建的这个来说不合适 &mdash; 我们希望尽可能减少磁盘占用。

因此，创建数据库的最后一步是压缩日志。考虑到随着日志增长，多个条目可能会为一个给定的键设置值。还需考虑只有修改该键的最新命令才会对该键的当前值产生影响：

| 索引 | 命令 |
|:---:|:--------|
| 0 | ~Command::Set("key-1", "value-1a")~ |
| 20 | Command::Set("key-2", "value-2") |
| | ... |
| 100 | Command::Set("key-1", "value-1b") |

在这个例子中，显然索引 0 处的命令是冗余的，因此不需要存储。日志压缩就是通过移除冗余来重建日志：

| 索引 | 命令 |
|:---:|:--------|
| 0 | Command::Set("key-2", "value-2") |
| | ... |
| 99 | Command::Set("key-1", "value-1b") |

以下是你将使用的基本算法：

*如何*重建日志取决于你。考虑一些问题，例如：天真的解决方案是什么？你需要多少内存？压缩日志所需的最少复制量是多少？压缩可以在原位进行吗？如果压缩失败，如何维护数据完整性？

到目前为止，我们一直在提到“日志”，但实际上数据库通常将许多日志存储在不同的文件中。如果你将日志分散在多个文件中，可能会发现压缩日志更容易。

*为你的数据库实现日志压缩。*

恭喜你！你已经编写了一个功能齐备的数据库。

如果你对此感到好奇，现在正是开始将你的键/值存储与 [sled]、[bitcask]、[badger] 或 [RocksDB] 等其他存储引擎的性能进行比较的好时机。你可能会喜欢研究它们的架构，思考它们与你的架构有何不同，以及架构如何影响性能。接下来的几个项目将给你提供优化的机会。

[sled]: https://github.com/spacejam/sled
[badger]: https://github.com/dgraph-io/badger
[RocksDB]: https://rocksdb.org/

写得不错，朋友。享受一段美好的休息时间吧。
