# PNA Rust 项目 3：同步客户端-服务器网络

**任务**：创建一个*单线程*、持久化的键/值存储*服务器和客户端*，它们通过*自定义协议进行同步网络通信*。

**目标**：

- 创建一个客户端-服务器应用程序
- 使用 `std` 网络 API 编写自定义协议
- 为服务器引入日志记录 (logging)
- 使用 trait 实现可插拔的存储后端
- 将手写的后端与 `sled` 进行基准测试 (benchmark)

**主题**：`std::net`、日志记录、trait、基准测试。

<!-- TODO **扩展**：接收信号时关闭。 -->

- [简介](#user-content-简介)
- [项目规范](#user-content-项目规范)
- [项目设置](#user-content-项目设置)
- [第 1 部分：命令行解析](#user-content-第-1-部分命令行解析)
- [第 2 部分：日志记录](#user-content-第-2-部分日志记录)
- [第 3 部分：客户端-服务器网络设置](#user-content-第-3-部分客户端-服务器网络设置)
- [第 4 部分：通过网络实现命令](#user-content-第-4-部分通过网络实现命令)
- [第 5 部分：可插拔存储引擎](#user-content-第-5-部分可插拔存储引擎)
- [第 6 部分：基准测试](#user-content-第-6-部分基准测试)

## 简介

在本项目中，你将创建一个简单的键/值服务器和客户端。它们将通过你自定义设计的网络协议进行通信。你将使用标准的日志 crate 发出日志，并正确处理跨越网络边界的错误。一旦你拥有一个正常运行的客户端-服务器架构，你就需要将存储引擎抽象到 trait 之后，并比较你的引擎与 [`sled`] 引擎的性能。

## 项目规范

该 Cargo 项目 `kvs` 会构建一个名为 `kvs-client` 的命令行键值存储客户端，以及一个名为 `kvs-server` 的键值存储服务器，两者都会调用名为 `kvs` 的库。客户端通过自定义协议与服务器通信。

`kvs-server` 可执行文件支持以下命令行参数：

- `kvs-server [--addr IP-PORT] [--engine ENGINE-NAME]`

  启动服务器并开始监听传入连接。`--addr` 接受 IPv4 或 IPv6 地址以及端口号，格式为 `IP:PORT`。如果未指定 `--addr`，则监听 `127.0.0.1:4000`。

  如果指定了 `--engine`，则 `ENGINE-NAME` 必须是 "kvs"（使用内置引擎）或 "sled"（使用 sled 引擎）。如果是第一次运行（之前没有持久化数据），则默认值为 "kvs"；如果已有持久化数据，则默认为已在使用的引擎。如果之前持久化的数据与选定的引擎不同，请打印错误并以非零代码退出。

  如果绑定套接字失败、`ENGINE-NAME` 无效或 `IP-PORT` 解析失败，请打印错误并返回非零退出代码。

- `kvs-server -V`

  打印版本信息。

`kvs-client` 可执行文件支持以下命令行参数：

- `kvs-client set <KEY> <VALUE> [--addr IP-PORT]`

  将字符串键的值设置为字符串。

  `--addr` 接受 IPv4 或 IPv6 地址以及端口号，格式为 `IP:PORT`。如果未指定 `--addr`，则连接到 `127.0.0.1:4000`。

  在服务器错误或 `IP-PORT` 解析失败时，打印错误并返回非零退出代码。

- `kvs-client get <KEY> [--addr IP-PORT]`

  获取给定字符串键的字符串值。

  `--addr` 接受 IPv4 或 IPv6 地址以及端口号，格式为 `IP:PORT`。如果未指定 `--addr`，则连接到 `127.0.0.1:4000`。

  在服务器错误或 `IP-PORT` 解析失败时，打印错误并返回非零退出代码。

- `kvs-client rm <KEY> [--addr IP-PORT]`

  删除给定的字符串键。

  `--addr` 接受 IPv4 或 IPv6 地址以及端口号，格式为 `IP:PORT`。如果未指定 `--addr`，则连接到 `127.0.0.1:4000`。

  在服务器错误或 `IP-PORT` 解析失败时，打印错误并返回非零退出代码。在 "rm" 命令中，"未找到键" 也被视为错误。

- `kvs-client -V`

  打印版本信息。

所有错误消息都应打印到 stderr。

`kvs` 库包含四种类型：

- `KvsClient` - 实现 `kvs-client` 与 `kvs-server` 通信所需的功能
- `KvsServer` - 实现 `kvs-server` 响应 `kvs-client` 所需的功能
- `KvsEngine` trait - 定义 `KvsServer` 调用的存储接口
- `KvStore` - 手工实现 `KvsEngine` trait
- `SledKvsEngine` - 为 [`sled`] 存储引擎实现 `KvsEngine`。

[`sled`]: https://github.com/spacejam/sled

`KvsClient` 和 `KvsServer` 的设计由你决定，并将受到你的网络协议设计的影响。测试套件不会直接使用这两个类型，而只是通过 CLI 对其进行测试。

`KvsEngine` trait 支持以下方法：

- `KvsEngine::set(&mut self, key: String, value: String) -> Result<()>`

  将字符串键的值设置为字符串。

  如果写入失败，则返回错误。

- `KvsEngine::get(&mut self, key: String) -> Result<Option<String>>`

  获取字符串键的字符串值。
  如果键不存在，则返回 `None`。

  如果读取失败，则返回错误。

- `KvsEngine::remove(&mut self, key: String) -> Result<()>`

  删除给定的字符串键。

  如果键不存在或读取失败，则返回错误。

当将键设置为值时，`KvStore` 会将 `set` 命令以顺序日志的形式写入磁盘。当删除键时，`KvStore` 会将 `rm` 命令写入日志。在启动时，会重新评估日志中的命令，并在内存索引中记录每个键最后一次 set 命令的日志指针（文件偏移量）。

当使用 `get` 命令检索键的值时，它会搜索索引，如果找到，则从日志中加载并评估相应日志指针处的命令。

当未压缩的日志条目大小达到给定阈值时，`KvStore` 会将其压缩到新日志中，删除冗余条目以回收磁盘空间。

## 项目设置

接续之前的项目，删除之前的 `tests` 目录，并将此项目的 `tests` 目录复制到相应位置。本项目应包含一个名为 `kvs` 的库，以及两个可执行文件 `kvs-server` 和 `kvs-client`。

你需要在 `Cargo.toml` 中添加以下开发依赖项：

```toml
[dev-dependencies]
assert_cmd = "0.11"
criterion = "0.3"
predicates = "1.0.0"
rand = "0.6.5"
tempfile = "3.0.7"
walkdir = "2.2.7"
```

与之前的项目一样，添加足够的定义以使测试套件能够构建。

## 第 1 部分：命令行解析

与之前的项目相比，本项目的命令行解析几乎没有新内容。`kvs-client` 二进制文件接受与之前项目相同的命令行参数。现在 `kvs-server` 也有了自己的一套命令行参数需要处理，如之前的规范所述。

*完善 `kvs-server` 的命令行处理。*

## 第 2 部分：日志记录

生产环境的服务器应用程序通常具有健壮且可配置的日志记录。因此，现在我们将为 `kvs-server` 添加日志记录，并在进行过程中寻找有用的信息进行记录。在开发期间，通常使用 `debug!` 和 `trace!` 级别的日志来进行 "println 调试"。

Rust 中有两个著名的日志系统：[`log`] 和 [`slog`]。两者都导出了类似的宏，用于不同级别的日志记录，如 `error!`、`info!` 等。两者都是可扩展的，支持不同的后端，例如记录到控制台、文件、系统日志等。

[`log`]: https://docs.rs/log/
[`slog`]: https://docs.rs/slog/

主要区别在于 `log` 相当简单，仅记录格式化字符串；`slog` 功能丰富，支持“结构化日志”，其中日志条目是类型化的，并以易于解析的格式序列化。

`log` 起源于 Rust 最早期的阶段，当时它是编译器的一部分，然后是标准库的一部分，最后作为自己的 crate 发布。它由 Rust 项目组维护。`slog` 较新且独立维护。两者都被广泛使用。

对于这两个系统，都需要选择一个 "sink" crate，即记录器将日志发送到其中进行显示或存储。

*阅读有关它们的内容，选择你喜欢的一个，将它们添加为依赖项，然后修改 `kvs-server` 以在启动时（命令行解析之前）初始化日志记录。* 将其设置为输出到 stderr（也可以同时发送到其他地方，但必须输出到 stderr 才能通过此项目中的测试）。

在启动时记录服务器的版本号。还要记录配置信息，目前这意味着 IP 地址、端口和存储引擎的名称。

## 第 3 部分：客户端-服务器网络设置

接下来我们将设置网络。在本项目中，你将使用 `std::net` 中的基础 TCP/IP 网络 API：[`TcpListener`] 和 [`TcpStream`]。

[`TcpListener`]: https://doc.rust-lang.org/std/net/struct.TcpListener.html
[`TcpStream`]: https://doc.rust-lang.org/std/net/struct.TcpStream.html

在本项目中，服务器是同步且单线程的。这意味着你将监听套接字，然后接受连接，并逐个执行和响应命令。将来，在我们通往异步、多线程和高性能数据库的旅程中，我们将多次重新审视这个决定。

考虑你的手动测试流程。现在有两个可执行文件需要处理，你需要一种方法来同时运行它们。如果你像许多人一样，可能会使用两个终端，在一个终端中运行 `cargo run --bin kvs-server`，直到按下 CTRL-C，在另一个终端中运行 `cargo run --bin kvs-client`。

这是一个使用日志宏进行调试的好机会。记录每一个接受到的连接。

*在考虑协议之前，修改 `kvs-server` 以监听并接受连接，修改 `kvs-client` 以发起连接。*

## 第 4 部分：通过网络实现命令

在最后一个项目中，你定义了数据库接受的命令，并学习了如何使用 `serde` 序列化和反序列化它们。

现在是时候通过网络实现键/值存储了，远程执行到目前为止已在单个进程中实现的命令。正如你在上一个项目中为创建日志而进行的各种文件 I/O 工作一样，你将使用 `Read` 和 `Write` trait 序列化和流化命令。

你将设计一个网络协议。有多种方法可以将数据迁入和迁出 TCP 流，并且有许多决定要做。它是基于文本的协议还是二进制协议？数据如何从其内存格式转换为其字节流格式？是每个连接进行单个请求，还是多个？

请记住，它必须支持成功结果和错误，现在有两种错误：存储引擎生成的错误以及网络错误。

协议的所有细节都取决于你。测试套件根本不在乎数据如何从一端传输到另一端，只要结果正确即可。

*编写你的网络协议。*

## 第 5 部分：可插拔存储引擎

你的数据库有一个存储引擎 `KvStore`，由你实现。现在你要添加第二个存储引擎。

这样做的原因有很多：

- 不同的工作负载需要不同的性能特征。根据工作负载，某些存储引擎可能比其他引擎表现更好。
- 它为比较不同的后端提供了一个熟悉的框架。
- 它给了我们一个创建和使用 trait 的借口。
- 它给了我们一个编写一些对比基准测试的借口！

因此，你将从 `KvStore` 接口中 *提取* 一个新的 trait `KvsEngine`。这是一个经典的 *重构*，原有的代码被逐步转化为新的形式。在重构时，你通常希望将工作分解为最小的更改，以便持续构建和工作。

这是你最终需要达到的 API：

- `trait KvsEngine` 具有与 `KvStore` 相同的 `get`、`set` 和 `remove` 方法签名。
- `KvStore` 实现 `KvsEngine`，并且不再拥有自己的 `get`、`set` 和 `remove` 方法。
- `KvsEngine` 有一个新的实现 `SledKvsEngine`。稍后你需要使用 `sled` 库填充其 `get` 和 `set` 方法。

如果你的测试能够构建，你很可能已经为这些定义了桩。*现在是填充它们的时候了。* 将你的重构分解为一系列有意识的更改，并确保在继续之前，项目能够持续构建并通通过之前已通过的测试。

作为最后一步，你需要考虑当 `kvs-server` 以一个引擎启动、被终止，然后以不同的引擎重新启动时会发生什么。这种情况只能导致错误，你需要找出如何检测这种情况并报告错误。测试 `cli_wrong_engine` 反映了这种场景。

## 第 6 部分：基准测试

随着课程的进行，我们将越来越关注数据库的性能，探索不同架构的影响。鼓励你超越本文描述的模型，尝试进行自己的优化。

性能工作需要基准测试，所以现在我们要开始这项工作。有很多方法可以对数据库进行基准测试，使用像 [ycsb] 和 [sysbench] 这样的标准测试套件。在 Rust 中，基准测试从内置工具开始，所以我们将从那里开始。

[ycsb]: https://github.com/brianfrankcooper/YCSB
[sysbench]: https://github.com/akopytov/sysbench

Cargo 通过 `cargo bench` 支持基准测试。基准测试既可以使用 Rust 内置的基准测试组件 (benchmark harness) 编写，也可以使用外部组件编写。

内置组件根据具有 `#[bench]` 属性的函数创建基准测试。但是，它不能在 Rust 稳定分支上使用，仅在 [unstable book][tb] 和 [`test` crate docs][tc] 中有简要说明。然而，它在整个 Rust 生态系统中被广泛使用——使用它的 crate 即使可以用稳定版本编译，也会使用 nightly 版本进行基准测试。

[tb]: https://doc.rust-lang.org/stable/unstable-book/library-features/test.html
[tc]: https://doc.rust-lang.org/stable/test/index.html

该系统实际上已被弃用——它没有被更新，并且似乎永远不会被推向稳定分支。

无论如何，Rust 还有更好的基准测试组件。你将使用的是 [criterion]。你将使用它来满足你对 `kvs` 引擎与 `sled` 引擎性能差异的好奇心。

这些基准测试工具的工作方式是定义一个基准测试函数，并在该函数内部进行循环迭代，执行要进行基准测试的操作。基准测试工具将根据需要迭代多次，以便以统计显著性获得操作的持续时间。

请参阅 criterion 指南中的这个基本示例：

```rust
fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
	    b.iter(|| {
		    fibonacci(20)
		});
	});
}
```

对 `bench_function` 的调用定义了基准测试，对 `iter` 的调用定义了为基准测试运行的代码。调用 `iter` 之前和之后的代码不会被计时。

[criterion]: https://docs.rs/criterion

通过创建一个名为 `benches/benches.rs` 的文件来准备编写基准测试。与 `tests/tests.rs` 类似，Cargo 会自动找到此文件并将其作为基准测试进行编译。

首先编写以下基准测试：

- `kvs_write` - 使用 kvs 引擎，写入 100 个具有 1-100000 字节随机长度键和 1-100000 字节随机长度值的键值对。
- `sled_write` - 使用 sled 引擎，写入 100 个具有 1-100000 字节随机长度键和 1-100000 字节随机长度值的键值对。
- `kvs_read` - 使用 kvs 引擎，从之前写入的键中读取 1000 个值，键和值具有随机长度。
- `sled_read` - 使用 sled 引擎，从之前写入的键中读取 1000 个值，键和值具有随机长度。

（作为编写 4 个基准测试的替代方案，你也可以选择编写 2 个针对引擎参数化的基准测试，如 [criterion 手册][pb]中所述）。

[pb]: https://bheisler.github.io/criterion.rs/book/user_guide/benchmarking_with_inputs.html

这些规范并不完整，实现它们有很多细微之处。我们至少需要考虑三个因素：

- 哪些代码应该被计时（写在基准测试循环内），哪些代码不应该被计时（写在基准测试循环外）？
- 尽管使用了“随机”数，如何使每次循环迭代运行得完全相同。
- 在“读取”基准测试中，如何读取之前写入的同一组“随机”键。

这些都是相互关联的：某些代码需要仔细选择作为不计时的设置 (setup) 代码，并且需要适当地重复使用随机数生成器的种子值。

在所有情况下，可能返回错误的操作都应该使用 `assert!` 断言它们没有返回错误；在读取情况下，"get" 操作应该断言已找到该键。

可以使用 [`rand`] crate 生成随机数。

[`rand`]: https://docs.rs/crate/rand/

拥有基准测试后，使用 `cargo bench` 运行它们。

*编写上述基准测试，并比较 `kvs` 和 `sled` 之间的结果。*

*注意：请在无其他负载的机器上运行基准测试。基准测试结果对运行环境非常敏感，虽然 criterion 库尽力弥补“噪声”，但基准测试最好在没有其他活动进程的干净机器上进行。如果你有专门用于开发的备用机器，请使用它。如果没有，AWS 或其他云实例可能会比你的本地机器产生更一致的结果。*

<!-- TODO: criterion 输出示例 -->

编程愉快，朋友。好好休息一下。
