# 学习笔记：存储引擎对比

## 1. 为什么 `sled.rs` 这么简单？
`sled.rs` 实际上是一个**包装器 (Wrapper)**。它的代码之所以只有几行，是因为它站在了巨人的肩膀上。

*   **调用现成的库**：`sled` 是一个工业级的、高性能的嵌入式数据库引擎。所有关于如何高效读写磁盘、如何保证数据不损坏、如何管理内存缓存等极端复杂的逻辑，都已经由 `sled` 库的开发者写好了。
*   **职责委派**：在 `SledKvsEngine` 的实现中，我们只是简单地把 `set`、`get`、`remove` 这些指令转发给了 `sled` 对象。

## 2. 为什么 `kvs.rs` 这么复杂？
`kvs.rs` 是一个**从零开始的手写实现**。在这个文件里，你实际上是在“造”一个微型的数据库引擎。

它的复杂性源于它必须亲自处理原本由数据库库处理的所有底层细节：
*   **日志管理 (WAL)**：它必须自己决定如何把数据格式化为 JSON，然后追加到文件末尾。
*   **内存索引**：它必须维护一个 `BTreeMap`，记录每个 Key 到底在硬盘文件的哪个字节偏移量上。如果这个索引丢了，数据就找不到了。
*   **数据重放 (Replay)**：当程序启动时，它必须扫描整个日志文件，重新构建内存索引，这个逻辑在 `load` 函数中非常繁琐。
*   **空间回收 (Compaction)**：由于它是“只追加”模式，文件会一直增大。`kvs.rs` 必须自己实现一套逻辑（`compact` 函数），把旧的、无效的数据删掉，合并成新文件。这涉及多线程安全、文件更名、偏移量重新计算等极易出错的逻辑。

## 3. 三个维度的对比总结

| 维度 | `kvs.rs` (Bitcask 模式) | `sled.rs` (Sled B-Tree 模式) |
| :--- | :--- | :--- |
| **角色** | **实现者**：你自己编写存储逻辑 | **消费者**：你使用别人写好的存储逻辑 |
| **底层原理** | **Log-Structured**：顺序追加日志，依赖内存索引 | **B+ Tree (类似于)**：更复杂的树状磁盘结构 |
| **性能/健壮性** | 适合学习其原理。在大规模数据下，压缩逻辑可能成为瓶颈 | 生产级工具。经过高度优化，处理错误和并发的能力极强 |

## 总结
它们实现的功能是一样的。在项目中使用 `KvsEngine` 这个 Trait，就是为了让我们可以**在不改动业务代码的情况下，自由切换**这两种实现。

*   写 `kvs.rs` 是为了让你通过动手实践，深刻理解数据库底层是如何运作的。
*   写 `sled.rs` 是为了让你学会如何将现有的专业工具集成到你的架构中。
